---
title: "Calibrate rsofun with photocold branch"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
library(tidyverse)
library(ingestr)
library(knitr)
library(lubridate)
```


This workflow is adopted from the benchmarking in sofunBench (at v4.2), see [here](https://github.com/computationales/sofunBench/blob/main/tag_v4.2/benchmark_gpp_FLUXNET2015_ensemble_v4.2.Rmd)

## Load rsofun

Get rsofun, photocold branch, and install it.
```{r message=FALSE, warning=FALSE}
# devtools::install_github("computationales/rsofun@v4.2")
library(rsofun)
```


## Description

This is to run the same evaluation of GPP simulated by the P-model as done for [Stocker et al. (2020)](https://gmd.copernicus.org/articles/13/1545/2020/), using data from the FLUXNET2015 Tier 1 ensemble. Model forcing and observational GPP data are prepared as detailed in the vignette `prepare_inputs_rsofun.Rmd`. Respective files are available on Euler (`~/data/rsofun_benchmarking/df_drivers_fluxnet2015.Rdata`)

This assumes that the model is already calibrated (calibratable parameters are prescribed).

Note: For simulations used in Stocker et al. (2020), forcing data was written to files and read by Fortran. With the updated rsofun model, this is passed through R, using an object formatted like `rsofun::df_drivers`.

## Load data

Load drivers data frame (created by `prepare_inputs_FLUXNET2015_ensemble.Rmd`).
```{r}
load("~/data/rsofun_benchmarking/df_drivers_fluxnet2015.Rdata")
```

There seem to be some leap year dates which create problems for rsofun. Drop Feb. 29 dates.
```{r}
df_drivers_fluxnet2015 <- df_drivers_fluxnet2015 %>% 
  dplyr::select(sitename, forcing) %>% 
  unnest(forcing) %>% 
  dplyr::filter(!(month(date)==2 & mday(date)==29)) %>% 
  
  ## model requires flux per seconds now
  mutate(prec = prec / (60*60*24), ppfd = ppfd / (60*60*24)) %>% 
  
  ## assuming all precipitation in liquid form
  mutate(rainf = prec, snowf = 0) %>% 

  ## required for new version, but not used because   
  mutate(tmin = temp, tmax = temp) %>% 

  group_by(sitename) %>% 
  nest() %>%
  rename(forcing = data) %>% 
  right_join(
    df_drivers_fluxnet2015 %>% 
      dplyr::select(-forcing),
    by = "sitename"
  ) %>% 
  ungroup() %>% 
  rename(site_info = siteinfo, params_soil = df_soiltexture)

## change name to make compatible
df_drivers_fluxnet2015 <- df_drivers_fluxnet2015 %>% 
  mutate(forcing = purrr::map(forcing, ~rename(., rain = rainf, snow = snowf)))


# save(df_drivers_fluxnet2015, file = "~/data/rsofun_benchmarking/df_drivers_fluxnet2015.Rdata")
```

## Calibrate model

Define calibration sites.
```{r message=FALSE, warning=FALSE}
flue_sites <- readr::read_csv( "~/data/flue/flue_stocker18nphyt.csv" ) %>%
              dplyr::filter( !is.na(cluster) ) %>% 
              distinct(site) %>% 
              pull(site)

calibsites <- siteinfo_fluxnet2015 %>% 
  dplyr::filter(!(sitename %in% c("DE-Akm", "IT-Ro1"))) %>%  # excluded because fapar data could not be downloaded (WEIRD)
  # dplyr::filter(!(sitename %in% c("AU-Wom"))) %>%  # excluded because no GPP data was found in FLUXNET file
  dplyr::filter(sitename != "FI-Sod") %>%  # excluded because some temperature data is missing
  dplyr::filter( c4 %in% c(FALSE, NA) & classid != "CRO" & classid != "WET" ) %>%
  dplyr::filter( sitename %in% flue_sites ) %>%
  pull(sitename)
```

Use the [ingestr](https://github.com/stineb/ingestr) package once again, now for collecting calibration target data. I.e., GPP based on the nighttime flux decomposition method.
```{r warning=FALSE, message=FALSE}
filn <- "~/data/rsofun_benchmarking/ddf_fluxnet_gpp.Rdata"
if (!file.exists(filn)){
  settings_ingestr_fluxnet <- list(
    dir_hh = "~/data/FLUXNET-2015_Tier1/20191024/HH/", 
    getswc = FALSE,
    filter_ntdt = TRUE,
    threshold_GPP = 0.8,
    remove_neg = FALSE
    )

  ddf_fluxnet_gpp <- ingestr::ingest(
    siteinfo = siteinfo_fluxnet2015 %>% 
      dplyr::filter(sitename %in% calibsites),
    source    = "fluxnet",
    getvars = list(gpp = "GPP_NT_VUT_REF",
                   gpp_unc = "GPP_NT_VUT_SE"),
    dir = "~/data/FLUXNET-2015_Tier1/20191024/DD/",
    settings = settings_ingestr_fluxnet,
    timescale = "d"
    )
  save(ddf_fluxnet_gpp, file = filn)
} else {
  load(filn)
}
```

Define calibration settings.
```{r}
settings <- list(
  method      = "bayesiantools",
  targetvars  = c("gpp"),
  timescale   = list(targets_obs = "y"),
  metric      = cost_rmse_photocold,
  dir_results = "./",
  name        = "photocold",
  control     = list(
    sampler = "DEzs",
    settings = list(
    burnin = 1500,
    iterations = 5000
    )),
  par = list(
    kphio       = list(lower=0.03, upper=0.2,  init = 0.09),
    soilm_par_a = list(lower=0.00, upper=1.0,  init = 0.33),
    soilm_par_b = list(lower=0.00, upper=10.0, init = 1.5),
    kphio_par_a = list(lower=-20,  upper=10,   init = 0.00),
    kphio_par_b = list(lower=0.1,  upper=10.0, init = 0.50),
    kphio_par_c = list(lower=-200, upper=-1,   init = -50.0),
    kphio_par_d = list(lower=0.01, upper=10,   init = 0.1)
    )
)
```

Calibrate the model.
```{r warning=FALSE, message=FALSE, eval=FALSE}
overwrite <- TRUE
filn <- "../data/pars_calib_photocold.rds"
if (!file.exists(filn) || overwrite){
  set.seed(1982)
  pars <- calib_sofun(
    drivers  = dplyr::filter(df_drivers_fluxnet2015, sitename %in% calibsites),
    obs      = ddf_fluxnet_gpp,
    settings = settings
    )
  saveRDS(pars, file = filn)
} else {
  pars <- read_rds(filn)
}
```

The calibrated parameters are returned by `calib_sofun()` as part of the list:
```{r}
# print(pars$par)
```

Update model parameters.
```{r}
params_modl <- list(
    kphio       = pars$par[1],
    soilm_par_a = pars$par[2],
    soilm_par_b = pars$par[3],
    kphio_par_a = pars$par[4],
    kphio_par_b = pars$par[5],
    kphio_par_c = pars$par[6],
    kphio_par_d = pars$par[7]
  )
```


## Run model

<!-- Change variable names after version update. -->
<!-- ```{r} -->
<!-- df_drivers_fluxnet2015 <- df_drivers_fluxnet2015 %>%  -->
<!--   mutate(forcing = purrr::map(forcing, ~rename(., rain = rainf, snow = snowf))) -->
<!-- ``` -->

`"~/data/rsofun_benchmarking/df_drivers_fluxnet2015_allsites.Rdata"` is prepared by `benchmarking/collect_data/prepare_inputs_FLUXNET2015_allsites.Rmd`.

```{r warning=FALSE, message=FALSE}
output <- rsofun::runread_pmodel_f(
  df_drivers_fluxnet2015,
  par = params_modl
  )

saveRDS(output, file = "../data/output_photocold.rds")
```

## Run evaluation

Do evaluation only for sites where simulation was run.
```{r}
evalsites <- output %>% 
  mutate(ntsteps = purrr::map_dbl(data, ~nrow(.))) %>% 
  dplyr::filter(ntsteps > 0) %>% 
  pull(sitename)
```

Load standard benchmarking file with observational data for evaluation.
```{r}
load("~/data/rsofun_benchmarking/obs_eval_fluxnet2015.Rdata")
```

Define evaluation settings.
```{r}
settings_eval <- list(
  benchmark = list( gpp = c("fluxnet") ),
  sitenames = evalsites,
  agg       = 8
  )
```

And finally run the evaluation.
```{r warning=FALSE, message=FALSE, error=FALSE}
source("~/sofunCalVal/R/eval_sofun.R")
source("~/sofunCalVal/R/get_stats.R")
filn <- "../out_eval_photocold.rds"
overwrite <- TRUE
if (!file.exists(filn) || overwrite){
  out_eval <- eval_sofun( 
    output, 
    settings_eval, 
    settings_sims, 
    obs_eval = obs_eval, 
    overwrite = TRUE, 
    light = FALSE 
    )
  saveRDS(out_eval, file = filn)
} else {
  out_eval <- read_rds(filn)
}
```

## Evaluation results

### Metrics table

```{r}
out_eval$gpp$fluxnet$metrics %>% 
  bind_rows(.id = "Level") %>% 
  kable
```

### Visualisations

#### Correlations

```{r message=FALSE, warning=FALSE}
out_eval$gpp$fluxnet$plot$gg_modobs_xdaily
out_eval$gpp$fluxnet$plot$gg_modobs_spatial_annual
```

#### Mean seasonal cycle

```{r message=FALSE, warning=FALSE}
## plot
out_eval$gpp$fluxnet$data$meandoydf_byclim %>% 
  dplyr::filter(climatezone %in% c("Aw south", "BSk north", "Cfa north", "Cfb north", "Cfb south", "Csa north", "Csb north", "Dfb north", "Dfc north")) %>%
  dplyr::filter(koeppen_code != "-") %>% 
  pivot_longer(c(obs_mean, mod_mean), names_to = "source", values_to = "gpp") %>% 
  ggplot() +
  geom_ribbon(
    aes(x = doy, ymin = obs_min, ymax = obs_max), 
    fill = "black", 
    alpha = 0.2
    ) +
  geom_line(aes(x = doy, y = gpp, color = source), size = 0.4) +
  labs(y = expression( paste("Simulated GPP (g C m"^-2, " d"^-1, ")" ) ), 
       x = "DOY") +
  facet_wrap( ~climatezone ) +    # , labeller = labeller(climatezone = list_rosetta)
  theme_gray() +
  theme(legend.position = "bottom") +
  scale_color_manual(
    name="Setup: ",
    values=c("red", "black")
    # values=c("FULL" = "#DE1A1A", "Observed" = "black")
    )
```

#### Drought response

```{r message=FALSE, warning=FALSE}
source("../R/align_events.R")
source("../R/eval_droughtresponse.R")

df_dday_agg <- eval_droughtresponse( 
  df = out_eval$gpp$fluxnet$data$ddf %>% rename(site = sitename), 
  path_flue = "~/data/flue/flue_stocker18nphyt.csv",
  before=20, 
  after=105,
  leng_threshold = 10, 
  nbins=10, 
  do_norm=TRUE
  )

usecol = colorRampPalette( c("wheat3", "white") )( 5 )[2]

df_dday_agg %>% 
  ggplot() +
  # annotate("rect", xmin = 0, xmax = 105, ymin = -1.2, ymax = 2.2, alpha = .8, fill = usecol) +
  geom_hline(yintercept = 0, color = "black", linetype = "dotted") +
  geom_vline(xintercept = 0, color = "black", linetype = "dotted") +
  geom_line(
    aes(x = dday, y = median), size = 0.9) +
  geom_ribbon(
    aes(x = dday, ymin = q33, ymax = q66), 
    alpha = 0.3) +
  scale_color_manual(values = c("BRC" = "black", "FULL" = "royalblue"), name = "Setup") +
  scale_fill_manual(values = c("BRC" = "black", "FULL" = "royalblue"), name = "Setup") +
  ylim(-1.2, 2.2) + xlim(-20, 105) +
  scale_x_continuous(expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
  labs(x = "Days after drought onset", y = expression( paste( "Bias (g C m"^{-1}, " d"^{-1}, ")")) ) +
  theme_classic()
```

## Appendix

### Site list

```{r}
siteinfo_fluxnet2015 %>% 
  dplyr::filter(sitename %in% evalsites) %>% 
  kable()
```
